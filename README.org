* Evil-cleverparens
Use Vim/evil like modal editing with lisp without screwing up the structure of
your code. Tries to offer useful alternatives for behavior which would otherwise
be destructive.
** Installation
The recommended way to install is through =elpa=, though in its current state, the
package doesn't actually exist there yet, which means that you are here too
early. I will get it on =elpa= as soon as I have used it myself long enough to
make sure it works for the most part.

=M-x package-install evil-cleverparens=

To enable =evil-cleverparens=, put:

#+BEGIN_SRC emacs-lisp :results silent
(add-hook 'smartparens-enabled-hook #'evil-cleverparens-mode)
#+END_SRC

into your =.emacs= or =init.el= file, which will turn on =evil-cleverparens= when
=smartparens= is activated.

If you use =smartparens= with non-lispy modes you probably want to only activate
=evil-cleverparens= with certain major modes. To do this, you can replace the
former snippet with:

#+BEGIN_SRC emacs-lisp :results silent
(add-hook '<your-lispy-mode> #'evil-cleverparens-mode)
#+END_SRC
** Features
*** Editing
**** Yanking
*Problem*: You yank a region of text that contains unbalanced delimiters, so now
pasting that region into your buffer will result in an unbalanced mess. 

There are three solutions to this problem:
- Don't let the user make such mistakes by erroring out when they are issued.
- Let the user issue the command but ignore parts of it that would result in
  misaligned structure.
- Let the user issue the command, and fix it up by supplying the missing
  delimiters.

=evil-cleverparens= supports the latter two approaches. You can toggle the
behavior between balancing and ignoring behavior via =M-z=, or by binding
=evil-cp-override= to the key of your choice. If you are a user of the =diminish=
mode, you can see the current behavior from the mode-line indicated by =/i= or =/b=
for /ignoring/ or /balancing/ behavior. 

For example, if you have:

#+BEGIN_SRC emacs-lisp :results silent
  (foo
   )
#+END_SRC

And yank the first line, the balancing behavior will store =(foo)= in your
kill-ring, whereas the ignoring behavior will store just =foo= instead. 

***** =yy= aka line-wise yank
Yanking the whole-line with =yy= behaves as you'd expect, with the minor
difference that yanking unbalanced expressions won't insert the new-line that a
regular line-wise yank would do.
***** =Y= aka =evil-cp-yank-line=
Acts like regular =evil-yank-line= when the line is safe to yank as it
is. Otherwise it does what =paredit-copy-as-kill= does for any expression on
the current line. If you have:

#+BEGIN_SRC emacs-lisp :results silent
  (foo
   bar)
#+END_SRC

With point at the beginning of the buffer, then =Y= will yank the whole sexp
instead of just the first line.
**** Deleting
***** =dW=
=dW= follows the logic outlined above, and respects the ignoring / balancing
behavior as mentioned. Personally I think it's easier to use =dio= and =dao= to
delete by /symbol/ instead of WORD.
***** =dd=
If the line is balanced, acts like regular evil's =dd= would do. Otherwise deletes
the line while saving out any parentheses that would put the region out of
balance.

#+BEGIN_SRC emacs-lisp :results silent
  (defun im-a-function ()
    (i-do-stuff 1 2 3))
#+END_SRC

Calling =dd= on the first line of the function definition will result in:

#+BEGIN_SRC emacs-lisp :results silent
  ((i-do-stuff 1 2 3))
#+END_SRC

And repeating the command would delete everything.
***** =vd=
Deleting in visual mode works as you would expect, with the additional bonus
that visual-block-state is handled as well.
***** =D=
=evil-cp-delete-line= deletes from /point/ until the end of the line, or until it
reaches a point where deleting more would leave the line out of balance.

#+BEGIN_SRC clojure :results silent
  (map (fn [x] |(conj coll (rest x))) stuff)
#+END_SRC

So with point at marked by =|=, pressing =D= would leave you with:

#+BEGIN_SRC clojure 
  (map (fn [x]) stuff)
#+END_SRC
**** Changing
**** Splicing
*** Text Objects
=evil-cleverparens= adds the following text objects:
**** /Form/ bound to =f=
Form is either a s-expression or a string, as defined by =smartparens= for the
mode in question.
**** /Comment/ bound to =c=
Selecting an /outer/ comment means selecting both the comment delimiter and the
comment text, whereas selecting an /inner/ comment means selecting only the text
but not the comment delimiters.
**** /Defun/ bound to =d=
Selects the top-level s-expression.
**** /Symbol/ bound to =o=
This is actually part of regular =evil=, but I didn't know about it before diving
into this project. I now use =dio= to delete a symbol instead of =diW=.
*** Extra
**** Slurping and Barfing
**** Dragging
**** Wrapping
**** Raising
**** Splitting
**** Quick insert
** See Also
=evil-cleverparens= is not the first Emacs/evil mode that tries to make structural
editing of lisp-like languages easier. You might enjoy checking out the
following modes as well:
*** [[https://github.com/abo-abo/lispy][abo-abo/lispy]]
Very rich in features but doesn't attempt to conform to the =vim/evil= layout of bindings.
*** [[https://github.com/roman/evil-paredit][roman/evil-paredit]]
Prevents the user from messing up their parentheses by erroring
out. =evil-cleverparens= originally started out as a fork of this project, with
the goal of doing something useful instead of throwing an error in situations
where it would make sense.
*** [[https://github.com/syl20bnr/evil-lisp-state][syl20bnr/evil-lisp-state]]
As the name suggests, this project creates an additional state for editing
lisp in =evil=.
*** [[https://github.com/expez/evil-smartparens][expez/evil-smartparens]]
Had I known of this project when starting out I would have just contributed to
it instead of writing a lot of the same functionality on my own, but by the
time I discovered it I had already so much code in place that I decided to
continue with my own version. Some of the code in =evil-cleverparens= is lifted
directly from here, and the modes work roughly the same. As far as I am aware,
the two projects are different in the following ways:
  - Deleting by line is different. In =evil-smartparens= the region to delete is
    determined in part by the location of the point, and the maximum safe
    region that this can be expanded to. =evil-cleverparens= on the other hand
    deletes everything except parentheses / string delimiters that would
    unbalance the region, and joins the next line to where the last opening
    parentheses of the deleted line existed.
  - When yanking an unbalanced region, =evil-cleverparens= gives you the option
    of choosing between ignoring (the =evil-smartparens= way) or supplementing
    the offending parentheses in kill-ring via
    =evil-cleverparens-balance-yanked-region=. 
** Limitations and the Escape Hatch
Ensuring that a region is safe can be expensive. Similar to =evil-smartparens=,
=evil-cleverparens= provides a variable =evil-cleverparens-threshold= that
controls how large the region should be before defaulting to the regular and
unsafe =evil= functions. 

Another feature stolen from =evil-smartparens= is an escape hatch,
=evil-cp-override=, which is bound to =o= in =visual-state=. Pre-fixing another
command with it will make =evil-cleverparens= default to using the regular =evil=
alternatives. =r= and =R= are the same as in regular =evil= so those can be used to
fix annoying situations as well.
** Disclaimer
This is my first Emacs Lisp project more than 100 lines long, so the code is
likely ugly and likelihood of bugs is quite high. Bug reports/fixes are
welcome. 
